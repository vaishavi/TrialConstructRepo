/// <reference types="node" />
import CIPConnectionState from "./CIPConnectionState";
import WebSocketClient from "../websocket/WebSocketClient";
export default class CIPClient {
    private _state;
    private readonly _maxHeartBeatAttempts;
    private readonly _internalHeartBeatInterval;
    private readonly maxIntervalBetweenPackets;
    private _lastPacketReceivedAt;
    private _heartBeatSupported;
    private _extendedLengthSupported;
    private _unicodeSupported;
    private _programReadySupported;
    private _serialSize;
    private readonly _webSocketClient;
    private _cipPacketHandler;
    private _virtualConnectionHandle;
    private _heartBeatTimer;
    private _heartBeatOutgoing;
    private _connected;
    private _cipProgramIdentifier;
    constructor(webSocketClient: WebSocketClient);
    cancelExpectedResponseTimeouts(): void;
    incrementHeartBeatOutgoing(): void;
    resetReconnectTimeout(): void;
    get heartBeatTimer(): NodeJS.Timeout;
    set heartBeatSupported(value: boolean);
    get heartBeatSupported(): boolean;
    set extendedLengthSupported(value: boolean);
    get extendedLengthSupported(): boolean;
    set isUnicodeSupported(value: boolean);
    get isUnicodeSupported(): boolean;
    set isProgramReadySupported(value: boolean);
    get isProgramReadySupported(): boolean;
    set serialSize(value: number);
    get serialSize(): number;
    resetHeartBeatOutgoing(): void;
    get heartBeatOutgoing(): number;
    get state(): CIPConnectionState;
    get webSocketClient(): WebSocketClient;
    get connected(): boolean;
    set connected(connected: boolean);
    setLastPackedReceivedAt(): void;
    initializeHeartBeat(): void;
    initializeUpdateRequest(): void;
    initializeEndOfJoinStatusResponse(): void;
    transitionTo(newState: CIPConnectionState): void;
    reset(): void;
    connectToCCS(): void;
    handleCIPPacket(packetArrayBuffer: ArrayBuffer): void;
    set virtualConnectionHandle(virtualConnectionHandle: number);
    get virtualConnectionHandle(): number;
    get cipProgramIdentifier(): string;
    /**
     * Sends a Uint8Array of the following shape:
     * <0x0B>
     * <Length><Length>
     * <Handler><Handler>
     * <AuthenticationData...>
     */
    authenticate(): void;
    /**
     * Sends a Uint8Array of the following shape:
     * <0x26>
     * <Length><Length>
     * <DestCID><DestCID> - 2 bytes
     * <Mode> - 1 byte
     * <Type><Type> - 2 bytes
     * <ExtraFlags><ExtraFlags><ExtraFlags><ExtraFlags> - 4 bytes
     * <MACAddress><MACAddress><MACAddress><MACAddress><MACAddress><MACAddress> - 6 bytes
     * <DeviceMake...> - 50 bytes
     * <DeviceModel...> - 50 bytes
     * <ProgramName...> - 32 bytes * ProgramName => roomId
     * <Hostname...> - 64 bytes
     * <AuthenticationDataLength> - 2 bytes
     * <AuthenticationData...> - unknown number of bytes.
     * Total packet length without authentication data = 213
     */
    private sendDeviceRouterConnect;
    /**
     * Sends a Uint8Array of the following shape:
     * <0x0D>
     * <Length><Length>
     * <Handler><Handler> - 2 bytes
     * <Data0>....<DataN>
     */
    private sendHeartBeat;
    /**
     * Sends a Uint8Array of the following shape:
     * <0x0E>
     * <Length><Length>
     * <Handler><Handler> - 2 bytes
     * <Data0>....<DataN>
     */
    sendHeartBeatResponse(packetData: Uint8Array): void;
    /**
     * Sends a Uint8Array of the following shape:
     * <0x03>
     * <0x00><0x02>
     * <Handler><Handler> - 2 bytes
     */
    private sendDisconnect;
    /**
     * Sends a Uint8Array of the following shape:
     * <0x05>
     * <Length><Length>
     * <Handler><Handler> - 2 bytes
     * <0x02><0x03><0x1D> - 3 bytes, update request
     */
    private sendEndOfJoinStatusResponse;
    /**
     * Sends a Uint8Array of the following shape:
     * <0x05>
     * <Length><Length>
     * <Handler><Handler> - 2 bytes
     * <0x02><0x03><0x00> - 3 bytes, update request
     */
    private sendUpdateRequest;
    tryReconnect(): void;
    disconnect(reason?: string): void;
    /**
     * Used to construct the template for the packet data, that includes whether it's a smart object or not and compute the lengths
     * @param dataLength Used as extra space that will be filled up by the calling functions with what they need apart from this
     * @param smartObjectId
     * @param extendedLengthSupported
     */
    private static sendUpdateTemplatePacketBuilder;
    /**
     * Build the packet for sending serial
     * Basically there are 2 approaches:
     *      Does it support extended length ? If yes use 0x12 as packet type, otherwise use 0x5 as packet type
     *      Does it contain a smartobjectID ? If yes, use cresnet packet as 0x38 or 0x39. If not, use cresnet type 0x34 or 0x15.
     *      The above flow breaks down further based on whether extended length is support. If it's supported, based on smartobjectId use either 0x39 or 0x34, if it's not supported, based on smartobjectid use either 0x38 or 0x15.
     *
     * Based on the above these are the 4 possible packets that can be built:
     *
     * extended true, smartobject true
     * <0x12> <length highbyte> <length lowbyte> <handler> <handler> <cresnet length> <cresnet length> <0x39> <smartjoinid MSB> <smartjoinid> <smartjoinid> <smartjoinid LSB> <cresnet length> <cresnet length> <0x34> <channel highbyte> <channel lowbyte> <flags> [<data>]
     * extended true, smartobject false
     * <0x12> <length highbyte> <length lowbyte> <handler> <handler> <cresnet length> <cresnet length> <0x34> <channel highbyte> <channel lowbyte> <flags> [<data>]
     * extended false, smartobject true
     * <0x5> <length highbyte> <length lowbyte> <handler> <handler> <cresnet length> <0x38> <smartjoinid MSB> <smartjoinid> <smartjoinid> <smartjoinid LSB> <cresnet length> <0x15> <channel highbyte> <channel lowbyte> <flags> [<data>]
     * extended false, smartobject false
     * <0x5> <length highbyte> <length lowbyte> <handler> <handler> <cresnet length> <0x15> <channel highbyte> <channel lowbyte> <flags> [<data>]
     * @param value
     * @param channelId
     * @param smartObjectId
     */
    sendUpdateString(value: string, channelId: number, smartObjectId?: number): void;
    /**
     * Build the packet for sending analog packets. Unlike the serial builder, we will always use type 0x05 and 0x14 for analog, so we do not care whether extended length is supported or not.
     * Expected output packets
     *      If there's a smartobjectid
     *        <0x05> <length highbyte> <length lowbyte> <handler> <handler> <smartobject length> <0x38> <smartobjectid MSB> <smartobjectid> <smartobjectid> <smartobjectid LSB> <0x05> <0x14> <Channel Highbyte> <Channel Lowbyte> <Value Highbyte> <Value lowbyte>
     *      If there's no smartobjectid
     *        <0x05> <length highbyte> <length lowbyte> <handler> <handler> <0x05> <0x14> <Channel Highbyte> <Channel Lowbyte> <Value Highbyte> <Value lowbyte>
     *  @param value
     * @param channelId
     * @param smartObjectId
     */
    sendUpdateNumber(value: number, channelId: number, smartObjectId?: number): void;
    /**
     * Build the packet for sending digitals. Use DIGITAL_IO or REPEAT_DIGITAL_IO
     * @param value
     * @param channelId
     * @param smartObjectId
     * @param repeatedDigital
     */
    sendUpdateBoolean(value: boolean, channelId: number, smartObjectId?: number, repeatedDigital?: boolean): void;
}
