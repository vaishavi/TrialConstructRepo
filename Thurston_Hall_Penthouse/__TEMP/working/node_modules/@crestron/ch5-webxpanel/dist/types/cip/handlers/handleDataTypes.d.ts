import CIPClient from "../CIPClient";
/**
 * Expected format - Type 0x00 - Digital I/O
 * <0x03> <0x00> <LowByte> <HighByte> - Turn on <HighByte LowByte>, HighByte LowByte in range [0...0x7FFF], button press
 * <0x03> <0x00> <LowByte> <0x80 + HighByte> - Turn off <HighByte LowByte>, HighByte LowByte in range [0...0x7FFF], button release
 * <CNT> <0x00> <LowByte> <HighByte> - Multisignal extension, repeat for each new signal
 * @param packet Packet starting with the <cnt> bytes
 * @param smartObjectId
 */
export declare function handleDigitalIO(packet: Uint8Array, smartObjectId?: number): void;
/**
 * Expected format - Type 0x01 Analog I/O
 * <0x03> <0x01> <Channel> <Value> (1 byte for channel, 1 byte for value) Set Channel to Value
 * <0x04> <0x01> <Channel> <Value HighByte> <Value LowByte> (1 byte for channel, 2 bytes for value) Set Channel to <HighByte LowByte>
 * <0x05> <0x01> <Channel HighByte> <Channel LowByte> <Value HighByte> <Value LowByte> (2 bytes for channel, 2 bytes for value) Set <ChannelHigh ChannelLow> to <HighByte LowByte>
 * <CNT>  <0x01> [<Channel HighByte> <Channel LowByte> <Value HighByte> <Value LowByte>] [<Channel LowByte> <Value HighByte> <Value LowByte>] [.....] - Similar to the above one, but repeat the procedures for all the channels
 * @param packet
 * @param smartObjectId
 */
export declare function handleAnalogIO(packet: Uint8Array, smartObjectId?: number): void;
/**
 * Expected format - Type 0x03 Command (Control)
 * Some possible formats that we are interested in:
 * <0x02> <0x03> <0x16> - End of update
 * <0x02> <0x03> <0x19> - Request status of multiple joins - Digital
 * <0x02> <0x03> <0x1A> - Request status of multiple joins - Analog
 * <0x02> <0x03> <0x1B> - Request status of multiple joins - Serial
 * <0x02> <0x03> <0x1C> - End of join status query
 * @param packet Packet starting with the <cnt> bytes
 * @param cipClient CipClient instance
 */
export declare function handleControl(cipClient: CIPClient, packet: Uint8Array): void;
/**
 * Expected format - Type 0x14 Symmetrical Analog Packets - Similar to type 0x01
 * <0x05> <0x01> <Channel HighByte> <Channel LowByte> <Value HighByte> <Value LowByte> (2 bytes for channel, 2 bytes for value) Set <ChannelHigh ChannelLow> to <HighByte LowByte>
 * <CNT>  <0x01> [<Channel HighByte> <Channel LowByte> <Value HighByte> <Value LowByte>] [<Channel LowByte> <Value HighByte> <Value LowByte>] [.....] - Similar to the above one, but repeat the procedures for all the channels
 * @param packet
 * @param smartObjectId
 */
export declare function handleSymmetricalAnalogPackets(packet: Uint8Array, smartObjectId?: number): void;
export declare function handleExtendedLengthSerialDataIndirectText(packet: Uint8Array, smartObjectId?: number): void;
/**
 * Expected format - Type 0x15 Multi-channel serial variation, similar to 0x34 but with only 1 byte for cresnet length
 * <CNT> <15> <Channel HighByte> <Channel LowByte> <flags> [data ...] - Check type 0x15 for flags explanation, data can not exist, if it's the case send empty string.
 * flags b0 = 1 [data] represents start of a new message
 * flags b1 = 1 [data] represents end of a message
 * @param packet
 * @param smartObjectId
 */
export declare function handleSerialIOIndirectText(packet: Uint8Array, smartObjectId?: number): void;
/**
 * Expected format - Type 0x1E General RCB
 * <CNT> <0x1E> <4 bytes for TIME (MSB ... LSB)> <2 bytes for channel 1> <2 bytes for terminus level 1> <1 byte for flag 1> ... [<2 bytes for channel N> <2 bytes for terminus level N> <1 byte for flag N>]
 * Time is in format of hundredths of a second (5s = 0x000001F4)
 * flags bit 0 is 0 (unsgined RCB (0 to 65535)), bit 0 is 1 (signed RCB(-32767 to +32768), signed values are in 2's complement)
 * @param packet
 * @param smartObjectId
 */
export declare function handleGeneralRCB(packet: Uint8Array, smartObjectId?: number): void;
export declare function handleUnmangledIndirectTextSupport(packet: Uint8Array): void;
/**
 * Expected format - Type 0x39
 * <CNT HighByte> <CNT LowByte> <0x39> [packet] ... [packet], [packet] can be one of the above packets, starting with cresnet length.
 * @param packet
 */
export declare function handleExtendedSmartObject(packet: Uint8Array): void;
/**
 * Expected format - Type 0x38
 * <CNT> <0x38> [packet] ... [packet]
 * @param packet
 */
export declare function handleSmartObject(packet: Uint8Array): void;
